<h1>Proof-of-concept <em>rename</em> refactoring</h1>

<p>This is a continuation of an exercise to learn how difficult it is to add refactoring support to a text editor or integrated development environment (IDE). There's no intent to produce a fully-featured and robust solution, but just in case it proves to be useful I want to focus on a couple of tools that don't already have satisfactory refactoring support. </p>

<p>We'll start with Microsoft VSCode, a modern text editor that has gained a lot of popularity in recent years. It has very limited support for refactoring compared with its "older sibling", VisualStudio. </p>

<h2>Rename refactoring for VSCode</h2>

<p>This is a crude and limited proof-of-concept implementation of a basic <em>rename</em> refactoring, implemented as a VSCode extension. The purpose is to explore the difficulty of implementing refactoring support as one or more VSCode extensions. </p>

<h3>Starting point</h3>

<p>In <a href="https://neopragma.com/2020/05/refactoring-the-hard-way-part-1/">the first part of our exploration</a>, we implemented some basic <em>raname</em> functionality in Bash. It isn't a complete implementation, but it can operate on multiple files and provides a crude sort of <em>undo</em> functionality by copying the original files before making changes. Let's get a sense of how difficult it would be to do something similar as a VSCode extension.</p>

<h3>Step 1: Generate a boilerplate extension</h3>

<p>VSCode extensions are generally written in TypeScript or JavaScript. We'll use TypeScript here. To work on VSCode extensions we're in the Node.js and npm world, so if you want to play with this you should configure a development environment accordingly. </p>

<p>Details of how to write a VSCode extension are covered in the tutorial at <a href="https://code.visualstudio.com/api/get-started/your-first-extension">https://code.visualstudio.com/api/get-started/your-first-extension</a> and in the VSCode documentation. That's not our focus here, so we'll just assume all that. </p>

<p>We'll start with a boilerplate VSCode extension generated by Yeoman: </p>

<pre>
yo code 
</pre>

<p>It asks a few questions before generating a boilerplate "Hello, World!" extension. You get something like this:</p>

<pre>
~ $ mkdir rename-vscode
~ $ cd rename-vscode
rename-vscode $ yo code

     _-----_     ╭──────────────────────────╮
    |       |    │   Welcome to the Visual  │
    |--(o)--|    │   Studio Code Extension  │
   `---------´   │        generator!        │
    ( _´U`_ )    ╰──────────────────────────╯
    /___A___\   /
     |  ~  |     
   __'.___.'__   
 ´   `  |° ´ Y ` 

? What type of extension do you want to create? New Extension (TypeScript)
? What's the name of your extension? Rename
? What's the identifier of your extension? rename
? What's the description of your extension? Proof-of-concept Rename refactoring for VSCode
? Initialize a git repository? Yes
? Which package manager to use? npm
   create rename/.vscode/extensions.json
   create rename/.vscode/launch.json
   create rename/.vscode/settings.json
   create rename/.vscode/tasks.json
   create rename/src/test/runTest.ts
   create rename/src/test/suite/extension.test.ts
   create rename/src/test/suite/index.ts
   create rename/.vscodeignore
   create rename/.gitignore
   create rename/README.md
   create rename/CHANGELOG.md
   create rename/vsc-extension-quickstart.md
   create rename/tsconfig.json
   create rename/src/extension.ts
   create rename/package.json
   create rename/.eslintrc.json
</pre>

<p>Among other things, that generates a <em>package.json</em> file containing some configuration settings for the extension and an <em>extension.ts</em> file containing the source code for the extension. We'll do most of our coding in those two files. </p>

<h3>Steps in the <em>rename</em> process</h3>

<p>Basically we need code that does the following: </p>

<ol>
<li>Pick up the highlighted text in the currently-active editor pane. </li>
<li>Ask the user to enter the replacement text for the <em>rename</em> refactoring. </li>
<li>Ask the user to confirm that they want to replace text <em>a</em> with text <em>b</em>.</li>
<li>Make a backup of each file that will be affected by the change. </li>
<li>Make the change in all relevant files. </li>
</ol>

<p>The <em>undo</em> feature is a separate command. It needs to do the following: </p>

<ol>
<li>Copy the backup files over the modified ones. </li>
</ol>

<h3>The bones of the extension</h3>

<p>So far, we have enough code to show the general structure of a VSCode extension that could support a <em>rename</em> operation. It's crude and incomplete, but here's where we are just now. This is file <em>src/extension.ts</em>.</p>

<pre>
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    let disposable = vscode.commands.registerCommand('rename.refactor', getTextToRefactor);
    context.subscriptions.push(disposable);
}

export function deactivate() {}

async function getTextToRefactor() {
    const originalText = getSelectedText() || "";
    const replacementText = await solicitReplacementText(originalText) || "";
    replaceTextIfConfirmed(originalText, replacementText);
}

function getSelectedText() {
    const window = vscode.window;
    const editor = window.activeTextEditor;  
    if (editor) {  
        const selection = editor.selection;  
        if (selection) {  
            const originalText = editor.document.getText(selection); 
            if (originalText.length > 0) {
                return originalText;
            }
        }
    }
    return undefined;       
}

async function replaceTextIfConfirmed(originalText: string, replacementText: string) {
    const userConfirmation = await solicitUserConfirmation(originalText, replacementText);
    if (userConfirmation) {
        replaceText(originalText, replacementText);
    }   
}

function solicitReplacementText(originalText: string) {
    return vscode.window.showInputBox({
        placeHolder: "Enter replacement text",
        prompt: "Selected text: <" + originalText + ">"
    });
}

function solicitUserConfirmation(originalText: string|undefined, replacementText: string|undefined) {
    if (replacementText) {
        return vscode.window.showInputBox({
            value: 'Do you want to replace <' + originalText + '> by <' + replacementText + '>?'
        }); 
    }
}

function noTextSelected() {
    vscode.window.showInformationMessage('No text selected');
}

function replaceText(originalText: string, replacementText: string) {
    vscode.window.showInformationMessage("...and then a miracle occurs.");
}
</pre>

<p>That's hardly a complete implementation. As you can see, when the time finally comes to perform the actual text replacement, the extension just displays the message, "...and then a miracle occurs." </p>

<p>But this is a reasonable point to pause for an explanation. The code demonstrates it's feasible to build an extension to handle refactoring. I think it's advisable to proceed a bit further for proof-of-concept purposes. </p>

<p>First, I want to acknowledge the obvious: VSCode already has refactoring extensions, for instance for Python and (unsurprisingly) TypeScript. So there's no doubt it's feasible to do this. We needn't prove that. </p>

<p>There is a lack of refactoring support in this tool for Java and C#, which are the most widely-used languages for existing business applications, and therefore the languages most in need of refactoring support. Refactoring for Java is well supported in JetBrains IntelliJ IDEA, and for C# in Microsoft VisualStudio. </p>

<p>If you're interested in using lighter-weight development tools than those, you may appreciate improved refactoring support for those languages in tools like VSCode, Vim, Sublime Text, Atom, etc. So if we want to play with this idea, it makes sense to keep Java and C# in mind. </p>

<p>Up to this point, there's nothing language-specific in the implementation. It's only a thinking point. </p>

<p>Most of the sample code you find online for VSCode extensions has all the logic contained in the <em>activate</em> function in the <em>extension.ts</em> or <em>extension.js</em> file, glommed together into a big if/else structure. It's my habit to break things out into smaller methods. That's the reason there are several methods in place already, even though we haven't even begun to rename anything. </p>

<p>If you prefer to see all the logic in one place, you can structure your file in that way. It won't make any difference at execution time; it's a readability consideration. Most extensions probably won't have a lot of code, so the benefit of factoring out small methods may be small. But I'm old, and I have my habits. </p>

<h3>Find and replace text in one file</h3>

<p>Before we try to process the project directory tree, let's see if we can do a <em>rename</em> in one file. Many examples we can find online deal with the document that is open in the currently-active editor. As we are interested in processing files that are not open in any editor, let's begin by processing a single file without assuming it's open in an editor. </p>

<p>In principle we can use the <em>fs</em> module to read and write files. In the context of what the user is doing, that might not really be the best option. The user is a programmer who is in the middle of editing source code and configuration files. They might make a number of changes, including refactorings, before saving a file. </p>

<p>According to the VSCode extension API documentation, under <em>workspace</em> there's a method called <em>openTextDocument</em> that will return the contents of the file as it currently stands within the tool, including unsaved changes. The method returns a <em>TextDocument</em> instance that includes an indicator named <em>isDirty</em> that is set to <em>true</em> if the document contains unsaved changes. For our purposes, this would be better than a standard filesystem "read" operation, because we want to see what the user sees at the moment they invoke the <em>rename</em> operation. </p>

<p>Unfortunately, this is not straightforward. After hours of trial and error, I found a sequence of calls that would open a file as a <em>TextDocument</em> based on a Uri, but it didn't seem to work for relative paths. Then I learned this is by design, to avoid potential security issues because there's no way to guarantee the extension "should" have access to a given relative path. See <a href="https://github.com/microsoft/vscode/issues/34449">this bug report and response</a>. </p>

<p>There <em>is</em> a way to get the "root" directory of the VSCode project. That suggests that when we extend the functionality to search recursively through the project directory tree, the code will work as expected. For this particular step we want to see that the code can process a single file. I created a test file for the purpose and placed it in a particular location under the project directory tree, but that is a hard-coded, temporary solution. </p>

<p>I will admit to you that I had a lot of difficulty getting this far. I read a lot of documentation, examined a lot of sample code and existing extensions on Github, and spent hours doing trial and error. What I ended up with is a truly horrific and stupid implementation. It does the <em>rename</em> of all occurrences of the selected string within the single test file, but it does so by replacing the entire contents of the text document object. I just couldn't discover a better way in the time I was willing to spend on this exercise. </p>

<p>On a positive note, I am certainly achieving my goal of gaining appreciation for the work others have done to write refactoring plugins and extensions for editors and IDEs! </p>

<p>One thing that became clear is the extension API is rich, and if we take the time to learn it well, there's a lot we can do with it. But not today.</p>

<p>I am embarrassed to say the following code is where we've ended up so far: </p>

<pre>
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    let disposable = vscode.commands.registerCommand('rename.refactor', renameRefactoring);
    context.subscriptions.push(disposable);
}

export function deactivate() {}

async function renameRefactoring() {
    const originalText = getSelectedText() || "";
    const replacementText = await solicitReplacementText(originalText) || "";
    replaceTextIfConfirmed(originalText, replacementText);
}

function getSelectedText() {
    const window = vscode.window;
    const editor = window.activeTextEditor;  
    if (editor) {  
        const selection = editor.selection;  
        if (selection) {  
            const originalText = editor.document.getText(selection); 
            if (originalText.length > 0) {
                return originalText;
            }
        }
    }
    return undefined;       
}

async function replaceTextIfConfirmed(originalText: string, replacementText: string) {
    const userConfirmation = await solicitUserConfirmation(originalText, replacementText);
    if (userConfirmation) {
        processDocument(vscode.Uri.file("./test/testFile.ts"), originalText, replacementText);
    }   
}

function solicitReplacementText(originalText: string) {
    return vscode.window.showInputBox({
        placeHolder: "Enter replacement text",
        prompt: "Selected text: <" + originalText + ">"
    });
}

function solicitUserConfirmation(originalText: string|undefined, replacementText: string|undefined) {
    if (replacementText) {
        return vscode.window.showInputBox({
            value: 'Do you want to replace <' + originalText + '> by <' + replacementText + '>?'
        }); 
    }
}

function processDocument(uri: vscode.Uri, originalText: string, replacementText: string) {
    var documentUri: vscode.Uri = vscode.Uri.parse(vscode.workspace.rootPath + "/rename/src/test/testFile.ts");
    vscode.workspace.openTextDocument(documentUri).then((document: vscode.TextDocument) => {
        let modifiedText = document.getText().replace(new RegExp(originalText, 'g'), replacementText);
        var firstLine = document.lineAt(0);
        var lastLine = document.lineAt(document.lineCount - 1);
        var replacementRange = new vscode.Range(firstLine.range.start, lastLine.range.end);             
        vscode.window.showTextDocument(document, 1, false).then(e => { 
             e.edit(edit => {
                edit.replace(replacementRange, modifiedText);
                vscode.workspace.applyEdit;
             });
         });
    });
}

</pre>

<p>This clunky implementation is not pretty to behold. User interaction is via input boxes that pop up in the VSCode window. Other refactoring extensions I've seen on Github provide a much more natural and visually-pleasing user interface. There are many options in the extensions API, and given time to learn them we could improve this implementation. </p>

<h3>Find and replace text in all files</h3>

<p>In our shell implementation we passed a filename glob to <em>sed</em>. In a language-specific implementation, we can be smarter than that and choose appropriate files based on file type. The VSCode extension API provides a way to register specific file types for particular extension commands, so this can be pretty seamless. </p>

<p>For now, let's assume the <em>rename</em> will apply to all files in the project directory hierarchy. Our next step is to wrap the <em>processDocument</em> method in logic that walks the project directory tree. </p>

<p>The method <em>vscode.workspace.findFiles</em> returns a list of the absolute paths of all the files in the project workspace. This is just what we want. We'll apply the <em>rename</em> operation to the contents of each file in this list. A brute-force implementation, yes, but this is only an exploratory learning exercise and not a polished solution. </p>

<p>Method <em>findFiles</em> takes a filename glob for files to include and optionally another one for files to exclude, so it will be possible to refine this behavior later either by including language-specific "smarts" in the extension or by asking the user to enter a filename glob. </p>

<p>In <em>src/extension.ts</em>, the methods <em>processFiles</em> and <em>processDocument</em> were affected by this change. </p>

<pre>
function processFiles(originalText: string, replacementText: string) {
    vscode.workspace.findFiles('rename/src/**/*.ts').then((files) => {
        files.forEach((filePath) => {
            processDocument(filePath, originalText, replacementText);
        });
    });
}

function processDocument(uri: vscode.Uri, originalText: string, replacementText: string) {
    vscode.workspace.openTextDocument(uri).then((document: vscode.TextDocument) => {
        if(document.getText().search(originalText) > -0) {
            let modifiedText = document.getText().replace(new RegExp(originalText, 'g'), replacementText);  
            var firstLine = document.lineAt(0);
            var lastLine = document.lineAt(document.lineCount - 1);
            var replacementRange = new vscode.Range(firstLine.range.start, lastLine.range.end);             
            vscode.window.showTextDocument(document, 1, false).then(e => { 
                 e.edit(edit => {
                    edit.replace(replacementRange, modifiedText);
                    vscode.workspace.applyEdit;
                 });
             });
        }
    });
}
</pre>

<p>The filename glob passed to <em>findFiles</em> is still hardcoded, but it's a little bit less hard. Next step will be to prompt the user with a default glob and allow them to enter something different if they wish. </p>

<h3>User controls the filename glob for the <em>rename</em></h3>
